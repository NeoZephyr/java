## 启动参数
以 - 开头为标准参数，所有的 JVM 都要实现这些参数，并且向后兼容

-D 设置系统属性

以 -X 开头为非标准参数，基本都是传给 JVM 的，默认 JVM 实现这些参数的功能，但是并不保证所有 JVM 实现都满足，且不保证向后兼容。可以使用 java -X 命令来查看当前 JVM 支持的非标准参数

以 –XX: 开头为非稳定参数，专门用于控制 JVM 的行为，跟具体的 JVM 实现有关，随时可能会在下个版本取消

-XX:+-Flags 形式，+- 是对布尔值进行开关
-XX:key=value 形式，指定某个选项的值

### 系统属性
```
-Dfile.encoding=UTF-8
-Duser.timezone=GMT+08
-Dmaven.test.skip=true
-Dio.netty.eventLoopThreads=8
```

### 运行模式
-server：设置 JVM 使用 server 模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有 64 位能力的 JDK 环境下将默认启用该模式

-client：设置 JVM 使用 client 模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或者 PC 应用开发和调试。JDK1.7 之前在 32 位的 x86 机器上的默认值是 -client 选项

-Xint：在解释模式下运行，-Xint 标记会强制 JVM 解释执行所有的字节码，这会降低运行速度，通常低 10 倍或更多

-Xcomp：-Xcomp 参数与 -Xint 正好相反，JVM 在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化（注意预热）

-Xmixed：-Xmixed 是混合模式，将解释模式和编译模式进行混合使用，由 JVM 自己决定。这是 JVM 的默认模式，也是推荐模式

### 堆内存
-Xmx：最大堆内存

-Xms：堆内存空间的初始大小。指定的内存大小，并不是操作系统实际分配的初始值，而是 GC 先规划好，用到才分配。专用服务器上需要保持 –Xms 和 –Xmx 一致，否则应用刚启动可能就有好几个 FullGC。当两者配置不一致时，堆内存扩容可能会导致性能抖动

-Xmn：等价于 -XX:NewSize，使用 G1 垃圾收集器不应该设置该选项。官方建议设置为 -Xmx 的 1/2 ~ 1/4

-XX:MaxPermSize=size：这是 JDK1.7 之前使用的。Java8 默认允许的 Meta 空间无限大，此参数无效

-XX:MaxMetaspaceSize=size：Java8 默认不限制 Meta 空间，一般不允许设置该选项

-XX:MaxDirectMemorySize=size：系统可以使用的最大堆外内存，这个参数跟 -Dsun.nio.MaxDirectMemorySize 效果相同

-Xss：每个线程栈的字节数。与 -XX:ThreadStackSize=size 等价

### GC 相关
-XX:+UseG1GC：使用 G1 垃圾回收器
-XX:+UseConcMarkSweepGC：使用 CMS 垃圾回收器
-XX:+UseSerialGC：使用串行垃圾回收器
-XX:+UseParallelGC：使用并行垃圾回收器

Java 11+
-XX:+UnlockExperimentalVMOptions -XX:+UseZGC

Java 12+
-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC

### 分析诊断
-XX:+-HeapDumpOnOutOfMemoryError 选项，当 OutOfMemoryError 产生，
自动 Dump 堆内存

-XX:HeapDumpPath 选项，指定内存溢出时 Dump 文件的目录。如果没有指定则默认为启动 Java 程序的工作目录

-XX:OnError 选项，发生致命错误时执行的脚本

-XX:OnOutOfMemoryError 选项，抛出 OutOfMemoryError 错误时执行的脚本

-XX:ErrorFile=filename 选项，致命错误的日志文件名，绝对路径或者相对路径

-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1506，远程调试

### JavaAgent
Agent 可以通过无侵入方式来做很多事情，比如注入 AOP 代码，执行统计等等，权限非常大。设置 agent 的语法如下：
-agentlib:libname[=options]：启用 native 方式的 agent，参考 LD_LIBRARY_PATH 路径
-agentpath:pathname[=options]：启用 native 方式的 agent
-javaagent:jarpath[=options]：启用外部的 agent 库，比如 pinpoint.jar 等等
-Xnoagent：禁用所有 agent

开启 CPU 使用时间抽样分析：
JAVA_OPTS="-agentlib:hprof=cpu=samples,file=cpu.samples.log"


## 堆内存
新建一个对象时，对象会被优先分配到新生代的 Eden 区中，这时虚拟机会给对象定义一个对象年龄计数器（通过参数 -XX:MaxTenuringThreshold 设置）

当 Eden 空间不足时，虚拟机将会执行 Minor GC。这时 JVM 会把存活的对象转移到 Survivor 中，并给对象的年龄 +1。对象在 Survivor 中同样也会经历 MinorGC，每经过一次 MinorGC，对象的年龄将会 +1

可以通过参数 -XX:PetenureSizeThreshold 设置直接被分配到老年代的最大对象，这时如果分配的对象超过了设置的阀值，对象就会直接被分配到老年代，这样可以减少新生代的垃圾回收

JDK1.7 年轻代和老年代的比例是 1:2，可以通过 –XX:NewRatio 重置该配置项。年轻代中的 Eden 和 To Survivor、From Survivor 的比例是 8:1:1，可以通过 -XX:SurvivorRatio 重置该配置项

如果开启了 -XX:+UseAdaptiveSizePolicy 配置项，JVM 将会动态调整 Java 堆中各个区域的大小以及进入老年代的年龄，–XX:NewRatio 和 -XX:SurvivorRatio 将会失效

JDK1.8 默认开启 -XX:+UseAdaptiveSizePolicy 配置项，不要随便关闭 UseAdaptiveSizePolicy 配置项，除非你已经对堆内存有非常明确的规划了。否则 JVM 将会分配最小堆内存，年轻代和老年代按照默认比例 1:2 进行分配，年轻代中的 Eden 和 Survivor 则按照默认比例 8:2 进行分配

持久代/元数据区在 JDK1.8 之前的参数设置是 -XX:MaxPermSize，之后的参数设置是 -XX:MaxMetaspaceSize

## 垃圾回收
JVM 的内存区域中，程序计数器、虚拟机栈和本地方法栈这 3 个区域是线程私有的，随着线程的创建而创建，销毁而销毁；栈中的栈帧随着方法的进入和退出进行入栈和出栈操作，每个栈帧中分配多少内存基本是在类结构确定下来的时候就已知的。因此，垃圾回收的重点就是堆和方法区中的内存

堆中的回收主要是对象的回收，方法区的回收主要是废弃常量和无用的类的回收

一般一个对象不再被引用，就代表该对象可以被回收。目前有以下两种算法可以判断该对象是否可以被回收：
1. 引用计数算法：通过一个对象的引用计数器来判断该对象是否被引用了。每当对象被引用，引用计数器就会加 1；每当引用失效，计数器就会减 1。当对象的引用计数器的值为 0 时，就说明该对象不再被引用，可以被回收了。虽然引用计数算法的实现简单，判断效率也很高，但它存在着对象之间相互循环引用的问题

2. 可达性分析算法：GC Roots 是该算法的基础，GC Roots 是所有对象的根对象，在 JVM 加载时，会创建一些普通对象引用正常对象。这些对象作为正常对象的起始点，在垃圾回收时，会从这些 GC Roots 开始向下搜索，当一个对象到 GC Roots 没有任何引用链相连时，就证明此对象是不可用的。目前 HotSpot 虚拟机采用的就是这种算法

GC Roots 主要包含以下几类：
1. 虚拟机栈中引用的对象
2. 方法区中类静态属性实体引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中 JNI 引用的对象

以上两种算法都是通过引用来判断对象是否可以被回收。在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种：
强引用：被强引用关联的对象永远不会被回收
软引用：软引用关联的对象，只有当系统将发生内存溢出时，才回去回收软引用的引用对象
弱引用：只被弱引用关联的对象，只要发生垃圾回收事件，就会被回收
虚引用：被虚引用关联的对象的唯一作用是能在这个对象被回收时收到一个系统通知

JVM 垃圾回收遵循以下两个特性：
1. 自动性：Java 提供了一个系统级的线程来跟踪每一块分配出去的内存空间，当 JVM 处于空闲循环时，垃圾收集器线程会自动检查每一块分配出去的内存空间，然后自动回收每一块空闲的内存块
2. 不可预期性：一旦一个对象没有被引用了，该对象是否立刻被回收是不可预期的。很难确定一个没有被引用的对象是不是会被立刻回收掉，因为有可能当程序结束后，这个对象仍在内存中

Full GC 时机：
1. 年轻代晋升到老年代的对象大小，并比目前老年代剩余的空间大小还要大时
2. 当老年代的空间使用率超过某阈值时
3. 当元空间不足时（JDK1.7 永久代不足）
4. System.gc()


## gc 算法
### 标记-清除算法
算法分为标记、清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。该算法是最基础的收集算法，后续的收集算法都是基于这种思路并对其缺点进行改进而得到的

优点：
不需要移动对象，简单高效

缺点：
标记和清除过程的效率都不高。标记清除之后产生大量不连续的内存碎片，碎片太多可能会导致无法分配空间给较大对象而提前触发另一次垃圾收集动作

### 复制算法
该算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉

优点：
简单高效，不产生内存碎片

缺点：
内存使用率低，且有可能产生频繁复制问题，特别是在对象存活率较高的情况

### 标记-整理算法
标记过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

### 分代收集算法
把堆分为新生代和老年代，从而根据各个年代的特点采用最适当的收集算法

在新生代中，每次垃圾收集时都有大批对象死去，只有少量存活，则选用复制算法，这样只需要付出少量存活对象的复制成本就可以完成收集

在老年代中，由于对象存活率高、没有额外空间对它进行分配担保，则使用标记-清除或标记-整理算法来进行回收


## 垃圾收集器
### 串行 gc
回收算法：复制算法/标记-清除算法

单线程复制回收，简单高效，但会暂停程序导致停顿

-XX:+UseSerialGC：年轻代、老年代回收器为：Serial New、Serial Old
-XX:+USeParNewGC：改进版本的 Serial GC，年轻代、老年代回收器为：ParNew New、Serial Old，jdk1.8 中无效

### 并行 gc
回收算法：复制算法/标记-整理算法

并行回收器适用于多核服务器，主要目标是增加吞吐量。多线程复制回收，降低了停顿时间，但容易增加上下文切换

-XX:+UseParallelGC：年轻代、老年代回收器为：Parallel Scavenge、Serial Old
-XX:+UseParallelGC -XX:+UseParallelOldGC：年轻代、老年代回收器为：Parallel Scavenge、Parallel Old

-XX:ParallelGCThreads=N 指定 GC 线程数，其默认值为 CPU 核心数

### CMS
回收算法：标记-清除算法

-XX:+UseConcMarkSweepGC

CMS 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：
1. 不对老年代进行整理，而是使用空闲列表来管理内存空间的回收
2. 在标记-清除阶段的大部分工作和应用线程一起并发执行，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢 CPU 时间。默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4

如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么可以使用 CMS

CMS 最大的问题就是老年代内存碎片问题（因为不压缩），在某些情况下会造成不可预测的暂停时间，特别是堆内存较大的情况下

CMS 过程分为如下步骤：
1. Initial Mark，初始化标记：发生 STW，暂停所有应用线程，并行标记可直达的存活对象（包括根对象直接引用的对象，以及被年轻代中所有存活对象所引用的对象）
2. Concurrent Mark，并发标记：GC 线程和应用线程并发执行，从前一阶段找到的根对象开始递归遍历老年代，标记所有的存活对象
3. Concurrent Preclean，并发预清理：因为前一阶段是并发执行，对象可能会发生变化，JVM 会通过 Card 的方式将发生了改变的区域标记为脏区，这就是所谓的卡片标记
4. Final Remark，重新标记：发生 STW，暂停所有应用线程，完成老年代中所有存活对象的标记。因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程序的修改速度，所以需要一次 STW 暂停来处理各种复杂的情况
5. Concurrent Sweep，并发清理：删除不再使用的对象，并回收他们占用的内存空间
6. Concurrent Reset，并发重置：并发执行，重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备

### G1
G1 将堆划分为多个（通常是 2048 个）可以存放对象的小块堆区域。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起那就是老年代

G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理：每次只处理一部分内存块，称为此次 GC 的回收集。每次 GC 暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块。G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是：垃圾最多的小块会被优先收集

-XX:+UseG1GC -XX:MaxGCPauseMillis=50

-XX:G1NewSizePercent：初始年轻代占整个 Java Heap 的大小，默认值为 5%
-XX:G1MaxNewSizePercent：最大年轻代占整个 Java Heap 的大小，默认值为 60%
-XX:G1HeapRegionSize：设置每个 Region 的大小，单位 MB，需要为 1，2，4，8，16，32 中的某个值，默认是堆内存的 1/2000
-XX:ConcGCThreads：与 Java 应用一起执行的 GC 线程数量，默认是 Java 线程的 1/4
-XX:+InitiatingHeapOccupancyPercent：G1 内部并行回收循环启动的阈值，默认为 Java Heap 的 45%
-XX:G1HeapWastePercent：G1 停止回收的最小内存大小，默认是堆大小的 5%。GC 会收集所有的 Region 中的对象，但是如果下降到了 5%，就会停下来不再收集了
-XX:+GCTimeRatio：这个参数就是计算花在 Java 应用线程上和花在 GC 线程上的时间比率，默认是 9。主要的目的是让用户可以控制花在应用上的时间，G1 的计算公式是 100 / (1+GCTimeRatio)。如果参数设置为 9，则最多 10% 的时间会花在 GC 工作上面
-XX:MaxGCPauseMills：预期 G1 每次执行 GC 操作的暂停时间，单位是毫秒，默认值是 200 毫秒，G1 会尽量保证控制在这个范围内

G1 过程分为如下步骤：
1. 年轻代模式转移暂停：G1 通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂停时间。在应用程序刚启动时，G1 还没有采集到什么足够的信息，这时候就处于初始的 fully-young 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。拷贝的过程称为转移

2. 并发标记：在标记阶段开始时记下所有的存活对象，即使在标记的同时又有一些变成了垃圾。通过对象的存活信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择。这些信息在接下来的阶段会用来执行老年代区域的垃圾收集

有两种情况是可以完全并发执行的：
一、如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾
二、在 STW 转移暂停期间，同时包含垃圾和存活对象的老年代小堆块

当堆内存的总体使用比例达到一定数值，就会触发并发标记。这个默认比例是 45%。G1 的并发标记也是由多个阶段组成

初始标记：标记所有从 GC 根对象直接可达的对象
Root 区扫描：标记所有从根区域可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域
并发标记：只遍历对象图，并在一个特殊的位图中标记能访问到的对象
再次标记：这是一次 STW 停顿，以完成标记过程。G1 收集器会短暂地停止应用线程，停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象
清理：统计小堆块中所有存活的对象，并将小堆块进行排序，以提升 GC 的效率，维护并发标记的内部状态。所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的 STW 暂停

3. 转移暂停：并发标记完成之后，G1 将执行一次混合收集。就是不只清理年轻代，还将一部分老年代区域也加入到回收集中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停


某些情况下 G1 触发了 Full GC，会退化使用 Serial 收集器来完成垃圾的清理工作，GC 暂停时间将达到秒级别的：
1. 并发模式失败：G1 启动标记周期，但在 Mix GC 之前，老年代就被填满，这时候 G1 会放弃标记周期。解决办法：增加堆大小或者调整周期（例如增加线程数 -XX:ConcGCThreads 等)
2. 晋升失败：没有足够的内存供存活对象或晋升对象使用，由此触发了 Full GC

解决办法：
a) 增加 –XX:G1ReservePercent 选项的值（并相应增加总的堆大小）增加预留内存量
b) 通过减少 –XX:InitiatingHeapOccupancyPercent 提前启动标记周期
c) 也可以通过增加 –XX:ConcGCThreads 选项的值来增加并行标记线程的数目

3. 巨型对象分配失败：当巨型对象找不到合适的空间进行分配时，就会启动 Full GC，来释放空间

解决办法：增加内存或者增大 -XX:G1HeapRegionSize

### ZGC
-XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx16g

ZGC 最主要的特点包括：
1. GC 最大停顿时间不超过 10ms
2. 堆内存支持范围广，小至几百 MB 的堆空间，大至 4TB 的超大堆内存
3. 与 G1 相比，应用吞吐量下降不超过 15%
4. 当前只支持 Linux/x64 位平台，JDK15 后支持 MacOS 和 Windows 系统

### ShennandoahGC
-XX:+UnlockExperimentalVMOptions XX:+UseShenandoahGC -Xmx16g


## GC 组合
Serial + Serial Old 实现单线程的低延迟垃圾回收机制
ParNew + CMS 实现多线程的低延迟垃圾回收机制
Parallel Scavenge + Parallel Scavenge Old 实现多线程的高吞吐量垃圾回收机制


## GC 日志
-XX:+PrintGC：输出 GC 日志
-XX:+PrintGCDetails：输出 GC 的详细日志
-XX:+PrintGCTimeStamps：输出 GC 的时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps：输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）

-XX:+PrintHeapAtGC：在进行 GC 的前后打印出堆的信息
-Xloggc:../logs/gc.log：日志文件的输出路径

GCeasy 是一款非常直观的 GC 日志分析工具，可以将日志文件压缩之后，上传到 GCeasy 官网即可看到非常清楚的 GC 日志分析结果



## 内存调优
### 调优参考指标
GC 频率：高频的 FullGC 会给系统带来非常大的性能消耗，虽然 MinorGC 相对 FullGC 来说好了许多，但过多的 MinorGC 仍会给系统带来压力

堆内存：分析堆内存大小是否合适，年轻代和老年代的比例是否合适。如果内存不足或分配不均匀，会增加 FullGC，严重的将导致 CPU 持续爆满，影响系统性能

吞吐量：频繁的 FullGC 将会引起线程的上下文切换，增加系统的性能开销，从而影响每次处理的线程请求，最终导致系统的吞吐量下降

延时：JVM 的 GC 持续时间也会影响到每次请求的响应时间

### 调优方法
1. 减少 MinorGC

可以将年轻代设置得大一些，从而减少一些 MinorGC

```
java -jar -Xms4g -Xmx4g -Xmn3g heapTest.jar
```

扩容 Eden 区虽然可以减少 Minor GC 的次数，但会增加单次 Minor GC 的时间。单次 Minor GC 时间是由两部分组成：T1（扫描新生代）和 T2（复制存活对象）。如果增大新生代空间，Minor GC 的时间间隔可能会扩大到 600ms，此时一个存活 500ms 的对象就会在 Eden 区中被回收掉，此时就不存在复制存活对象了。可见，扩容后，Minor GC 时增加了 T1，但省去了 T2 的时间。通常在虚拟机中，复制对象的成本要远高于扫描成本

如果在堆内存中存在较多的长期存活的对象，此时增加年轻代空间，反而会增加 Minor GC 的时间。如果堆中的短期对象很多，那么扩容新生代，单次 Minor GC 时间不会显著增加。因此，单次 Minor GC 时间更多取决于 GC 后存活对象的数量，而非 Eden 区的大小

2. 减少 FullGC

在堆内存不足的情况下，增大堆内存空间，且设置初始化堆内存为最大堆内存，可以降低 Full GC 的频率

```
java -jar -Xms4g -Xmx4g heapTest.jar
```

如果大对象超过年轻代最大对象阈值，会被直接创建在老年代；即使被创建在了年轻代，由于年轻代的内存空间有限，通过 Minor GC 之后也会进入到老年代。这种大对象很容易产生较多的 Full GC


设置 Eden、Survivor 区比例：如果开启 AdaptiveSizePolicy，则每次 GC 后都会重新计算 Eden、From Survivor 和 To Survivor 区的大小，计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量。这个时候 SurvivorRatio 默认设置的比例会失效

在 JDK1.8 中，默认是开启 AdaptiveSizePolicy 的，可以通过 -XX:-UseAdaptiveSizePolicy 关闭该项配置，或显示运行 -XX:SurvivorRatio=8 将 Eden、Survivor 的比例设置为 8:2。如果大部分新对象都是在 Eden 区创建的，可以固定 Eden 区的占用比例，来调优 JVM 的内存分配性能

